<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>
        <!-- Babylon.js -->
        <script src="http://www.babylonjs.com/hand.minified-1.2.js"></script>
        <script src="http://www.babylonjs.com/cannon.js"></script>
        <script src="http://www.babylonjs.com/oimo.js"></script>
        <script src="http://www.babylonjs.com/babylon.js"></script>
        <script src="./eventHandlers.js"></script>
        <script src="./libs/pixi.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvasBottom, #renderCanvasTop {
                position: absolute;
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #renderCanvasTop {
                z-index: 2;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvasBottom"></canvas>
    <canvas id="renderCanvasTop"></canvas>
    <script>

        // =====
        // 
        // MAIN
        // 
        // =====

        var canvas = document.getElementById("renderCanvasBottom");
        window.babylon = new BABYLON.Engine(canvas, true);
        window.scene = new BABYLON.Scene(babylon);

        var canvas2D = document.getElementById("renderCanvasTop");
        window.pixi = new PIXI.WebGLRenderer(canvas2D.clientWidth, canvas2D.clientHeight, { view: canvas2D, transparent: true });
        window.scene2D = new PIXI.Container();
        window.graphics2D = new PIXI.Graphics();
        window.graphics2D.fillStyle = 'rgba(0, 0, 0, 1)';
        window.graphics2D.clear();
        window.scene2D.addChild(window.graphics2D);

        var game = {
            selectedElements : [],
            selectionStartPosition: null,
            selectionCurrentPosition: null,
            selectionEndPosition : null,
            selectionInProgress : false,
            rubberBand: null,
            rubberBandSelectionMesh: null,
            rubberBandSelectionSquare: null,
            meshTemplates: {

            },
            sidebarElements: {

            }
        };

        // =====
        // Init
        // =====

        var scene = createScene();

        babylon.runRenderLoop(function () {
            scene.render();
        });

        // =====
        // Rendering loop
        // =====

        requestAnimationFrame(pixiAnimate);
        function pixiAnimate() {
            requestAnimationFrame(pixiAnimate);
            graphics2D.clear();
            drawSidebar(graphics2D);
            if (game.selectionStartPosition && game.selectionCurrentPosition) {
                drawSelectionSquare(graphics2D, game.selectionStartPosition, game.selectionCurrentPosition);
            }
            pixi.render(scene2D);
        }

        // Resize
        window.addEventListener("resize", function () {
            babylon.resize();
            pixi.resize();
        });

        // =====
        // Set up scene, cameras, light, event handlers etc
        // =====

        function createScene() {
        
            var lights = createLights(scene);
            var materials = createMaterials(scene);

            window.camera = new BABYLON.FreeCamera("Camera", new BABYLON.Vector3(0, 400, -200), scene);
            camera.rotation.y = 0; // look straigt forward
            camera.rotation.x = 0.3 * Math.PI; // look slight down
            
            // =====
            // Meshes
            // =====

            // Templates
            var unitTemplate;
            game.meshTemplates.unit = unitTemplate = BABYLON.Mesh.CreateBox("UnitTemplate", 10, scene);
            unitTemplate.material = unitTemplate.originalMaterial = materials.yellowMaterial;
            unitTemplate.visibility = false;
            unitTemplate.selectable = true;

            var selectionRingTemplate;
            game.meshTemplates.selectionRing = selectionRingTemplate = BABYLON.Mesh.CreateDisc('selectionRing', 15, 32, scene);
            selectionRingTemplate.material = materials.selectionRingMaterial;;
            selectionRingTemplate.position.y = 0.1;
            selectionRingTemplate.rotation.x = Math.PI / 2;
            selectionRingTemplate.receiveShadows = true;
            selectionRingTemplate.visibility = false;
            selectionRingTemplate.selectable = false;

            // units
        	var units = [];
            for (var i = 0; i < 10; i++) {
                var unit = game.meshTemplates.unit.clone("unit");
                unit.visibility = true;
                unit.position = new BABYLON.Vector3(-i * 50, 5, 0);
                units.push(unit);
            }
        
        	// Ground
        	var ground = BABYLON.Mesh.CreateGround("Ground", 1000, 1000, 1, scene, true);
        	ground.material = materials.groundMaterial;
        	ground.selectable = false;
        	
            // =====
        	// Shadow
            // =====

        	var shadowGenerator = new BABYLON.ShadowGenerator(2048, lights.sun);
        	for (var index in units) {
        		shadowGenerator.getShadowMap().renderList.push(units[index]);	
        	}
        	shadowGenerator.useVarianceShadowMap = true;
        	ground.receiveShadows = true;
        	
            scene.registerBeforeRender(function () {
        		// ...
            });
        	
            // =====
            // Event handling
            // =====

            var eventHandlers = createEventHandlers();
        	
        	document.removeEventListener("keydown");
        	document.addEventListener("keydown", eventHandlers.onKeyDown, false);
        	canvas2D.addEventListener("pointerdown", eventHandlers.onPointerDown);
        	canvas2D.addEventListener("pointermove", eventHandlers.onPointerMove);
        	canvas2D.addEventListener("pointerup", eventHandlers.onPointerUp);
        	
            disableDefaultRightClickMenu();

            // =====
            // 
            // HELPER FUNCTIONS
            // 
            // =====

        	function setRubberBand(startPos, endPos) {
        	    var startPick = scene.pick(startPos.x, startPos.y, function (mesh) { return mesh == ground; });
        	    var endPick = scene.pick(endPos.x, endPos.y, function (mesh) { return mesh == ground; });
        	    if (!startPick.hit || !endPick.hit) {
        	        return;
        	    }
        	    var startPosOnFloor = startPick.pickedPoint;
        	    var endPosOnFloor = endPick.pickedPoint;
        	    game.rubberBandSelectionMesh = new BABYLON.MeshBuilder.CreateBox("rubberBand", { height: 100, width: endPosOnFloor.x - startPosOnFloor.x, depth: endPosOnFloor.z - startPosOnFloor.z, updateable: true }, scene);
        	    game.rubberBandSelectionMesh.position = new BABYLON.Vector3(startPosOnFloor.x + (endPosOnFloor.x - startPosOnFloor.x) / 2, 50, startPosOnFloor.z + (endPosOnFloor.z - startPosOnFloor.z) / 2);
        	    game.rubberBandSelectionMesh.visibility = false;
        	}

        	

        	function moveMeshTo(mesh, pos) {
        	    if (mesh.animations.length) {
        	        scene.getAnimatableByTarget(mesh).stop();
        	    }

        	    var path = pos.subtract(mesh.position);
        	    var length = Math.round(path.length());
        	    var framesCount = length / 2;

        	    var currentAnimation = new BABYLON.Animation("animation", "position", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        	    var animationFrames = [];
        	    animationFrames.push({
        	        frame: 0,
        	        value: mesh.position
        	    });
        	    animationFrames.push({
        	        frame: framesCount,
        	        value: pos
        	    });
        	    currentAnimation.setKeys(animationFrames);
        	    mesh.animations.push(currentAnimation);
        	    scene.beginAnimation(mesh, 0, framesCount, true);
        	    console.log("animating", mesh, "to", pos);
        	}

            // =====
            // Event handlers
            // =====

            function createEventHandlers() {
                var eventHandlers = {};

                eventHandlers.onKeyDown = onKeyDown;
                eventHandlers.onPointerDown = onPointerDown;
                eventHandlers.onPointerMove = onPointerMove;
                eventHandlers.onPointerUp = onPointerUp;

                return eventHandlers;
            }

            function onKeyDown(evt) {
                var key = String.fromCharCode(evt.keyCode);
                if (key == 'W') {
                    camera.cameraDirection.z += 10;
                }
                if (key == 'S') {
                    camera.cameraDirection.z -= 10;
                }
                if (key == 'D') {
                    camera.cameraDirection.x += 10;
                }
                if (key == 'A') {
                    camera.cameraDirection.x -= 10;
                }
                evt.stopPropagation();
            }

            function onPointerDown(evt) {
                if (isLeftClick(evt)) {
                    game.selectionStartPosition = { x: evt.clientX, y: evt.clientY };
                }
                evt.stopPropagation();
                evt.preventDefault();
                return false;
            }

            function onPointerMove(evt) {
                if (game.selectionStartPosition) {
                    game.selectionCurrentPosition = { x: evt.clientX, y: evt.clientY };
                }
            }

            function onPointerUp(evt) {
                game.selectionEndPosition = { x: evt.clientX, y: evt.clientY };
                deselectAllMeshes(units);
                clearSelectionSquare();
                if (game.selectionStartPosition) {
                    if (!isMouseMovedDuringSelection(game.selectionStartPosition, game.selectionEndPosition)) {
                        // Single selection
                        var pickInfo = scene.pick(evt.clientX, evt.clientY, function (mesh) { return mesh.selectable; });
                        if (pickInfo.hit) {
                            var currentMesh = pickInfo.pickedMesh;
                            game.selectedElements = [currentMesh];
                            selectMeshes(game.selectedElements, scene);
                        }
                    } else {
                        // Multi selection
                        setRubberBand(game.selectionStartPosition, game.selectionEndPosition);
                        game.selectedElements = getMeshesSelectedByRubberBand(scene, units, game.rubberBandSelectionMesh);
                        selectMeshes(game.selectedElements, scene);
                    }
                }
                if (isRightClick(evt)) {
                    var pickInfo = scene.pick(evt.clientX, evt.clientY, function (mesh) { return mesh == ground; });
                    if (pickInfo.hit) {
                        var targetPos = pickInfo.pickedPoint;
                        for (var index in game.selectedElements) {
                            var selectedElement = game.selectedElements[index];
                            targetPos.y = selectedElement.position.y;
                            moveMeshTo(selectedElement, targetPos);
                        }
                    }
                }
                game.selectionStartPosition = null;
                game.selectionCurrentPosition = null;
                game.selectionEndPosition = null;
            }
        
            return scene;
        	
        };

        // =====
        // 
        // UTIL FUNCTIONS
        // 
        // =====

        // =====
        // Lights
        // =====

        function createLights(scene) {
            var lights = {};

            lights.sun = new BABYLON.DirectionalLight("Sun", new BABYLON.Vector3(-1.5, -2, -1), scene);

            lights.atmospheric = new BABYLON.HemisphericLight("atmospheric", new BABYLON.Vector3(-1.5, 2, -1), scene);
            lights.atmospheric.diffuse = new BABYLON.Color3(1, 1, 1);
            lights.atmospheric.specular = new BABYLON.Color3(1, 1, 1);
            lights.atmospheric.groundColor = new BABYLON.Color3(0.1, 0.1, 0.1);
            lights.atmospheric.intensity = 0.4;

            return lights;
        }

        // =====
        // Materials
        // =====

        function createMaterials(scene) {
            var materials = {};

            // Selected ring material
            materials.selectionRingMaterial = createselectionRingMaterial(scene);

            // Yellow material
            materials.yellowMaterial = new BABYLON.StandardMaterial("yellow", scene);
            materials.yellowMaterial.diffuseColor = new BABYLON.Color3(1, 1, 0);

            // Ground material
            materials.groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            materials.groundMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);

            return materials;
        }

        function createselectionRingMaterial(scene) {
            var selectTexture = new BABYLON.DynamicTexture("selectTexture", 512, scene, true);
            // draw circle using 2d context
            var context = selectTexture._context;
            var invertY = true;
            var size = selectTexture.getSize();
            var posX = 256;
            var posY = 256;
            var radius = 220;
            context.arc(posX, posY, radius, 0, 2 * Math.PI, false);
            context.fillStyle = 'rgba(255, 255, 255, 0)';
            context.fill();
            context.lineWidth = 30;
            context.strokeStyle = 'rgb(0, 255, 0)';
            context.stroke();
            selectTexture.update(invertY);
            // create and return actual material
            var selectMaterial = new BABYLON.StandardMaterial('selectedBoxMaterial', scene);
            selectMaterial.diffuseTexture = selectTexture;
            selectMaterial.opacityTexture = selectTexture;
            return selectMaterial;
        }

        // =====
        // Selection
        // =====

        function deselectAllMeshes(meshes) {
            for (var index in meshes) {
                meshes[index].material = meshes[index].originalMaterial;
                if (meshes[index].selectionRing) {
                    meshes[index].selectionRing.dispose();
                }
            }
        }

        function getMeshesSelectedByRubberBand(scene, meshes, rubberband) {
            var selectedMeshes = [];
            scene.render();
            for (var index in meshes) {
                var mesh = meshes[index];
                if (rubberband.intersectsPoint(mesh.position)) {
                    selectedMeshes.push(mesh);
                }
            }
            return selectedMeshes;
        }

        function getBottomPositionOfMesh(mesh) {
            var pos = mesh.position.clone();
            var minimumPos = mesh.getBoundingInfo().boundingBox.minimumWorld;
            pos.y = minimumPos.y;
            return pos;
        }

        function getWidthXOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.x - mesh.getBoundingInfo().boundingBox.minimumWorld.x;
        }

        function getWidthZOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.z - mesh.getBoundingInfo().boundingBox.minimumWorld.z;
        }

        function getHeightOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.y - mesh.getBoundingInfo().boundingBox.minimumWorld.y;
        }

        function isLeftClick(evt) {
            return evt.button == 0;
        }

        function isRightClick(evt) {
            return evt.button == 2;
        }

        function isMouseMovedDuringSelection(startPos, endPos) {
            return startPos.x != endPos.x || startPos.y != endPos.y;
        }

        function selectMeshes(meshes, scene) {
            for (var index in meshes) {
                selectMesh(meshes[index], scene);
            }
        }

        function selectMesh(mesh, scene) {
            mesh.selectionRing = game.meshTemplates.selectionRing.clone("selectionRing");
            mesh.selectionRing.parent = mesh;
            mesh.selectionRing.visibility = true;
        }

        function drawSelectionSquare(graphics2D, startPos, endPos) {
            graphics2D.clear();
            graphics2D.lineStyle(2, 0x00FF00, 1);
            graphics2D.drawRect(startPos.x, startPos.y, (endPos.x - startPos.x), (endPos.y - startPos.y));
        }

        function clearSelectionSquare() {
            graphics2D.clear();
        }

        // =====
        // Sidebar rendering
        // =====

        function drawSidebar(scene2D) {
            if (!game.sidebarElements.parent) {
                game.sidebarElements.parent = new PIXI.Container();
                game.sidebarElements.parent.x = 10;
                game.sidebarElements.parent.y = 10;
                scene2D.addChild(game.sidebarElements.parent);
            }
            if (!game.sidebarElements.fps) {
                game.sidebarElements.fps = new PIXI.Text(babylon.fps, { font: '24px Verdana', fill: '#fff' });
                game.sidebarElements.parent.addChild(game.sidebarElements.fps);
            }
            game.sidebarElements.fps.text = "3D: " + Math.round(babylon.fps) + " fps";
        }

        // =====
        // General
        // =====

        function disableDefaultRightClickMenu() {
            document.addEventListener("contextmenu", function (evt) { evt.preventDefault(); });
        }

    </script>
</body>
</html>
