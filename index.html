<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Energia</title>
        <!-- Babylon.js -->
        <!--
        <script src="http://www.babylonjs.com/hand.minified-1.2.js"></script>
        <script src="http://www.babylonjs.com/cannon.js"></script>
        <script src="http://www.babylonjs.com/oimo.js"></script>-->
        <script src="./libs/babylon.js"></script>
        <script src="./libs/pixi.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvasBottom, #renderCanvasTop {
                position: absolute;
                width: 100%;
                height: 100%;
                touch-action: none;
            }

            #renderCanvasTop {
                z-index: 2;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvasBottom"></canvas>
    <canvas id="renderCanvasTop"></canvas>
    <script src="./static/js/energia.js"></script>
    <script>

        // =====
        // Init
        // =====

        window.canvas3D = document.getElementById("renderCanvasBottom");
        window.babylon = new BABYLON.Engine(window.canvas3D, true);
        window.scene3D = new BABYLON.Scene(window.babylon);

        window.canvas2D = document.getElementById("renderCanvasTop");
        window.pixi = new PIXI.WebGLRenderer(window.canvas2D.clientWidth, window.canvas2D.clientHeight, { view: window.canvas2D, transparent: true });
        window.scene2D = new PIXI.Container();

        // =====
        // Start
        // =====

        var options = {
            babylon : window.babylon,
            pixi : window.pixi,
            scene2D : window.scene2D,
            scene3D : window.scene3D,
            canvas2D : window.canvas2D,
            canvas3D : window.canvas3D
        }
        game.init(options);
        game.start();


        // =====
        // Selection
        // =====

        /* 

        function getBottomPositionOfMesh(mesh) {
            var pos = mesh.position.clone();
            var minimumPos = mesh.getBoundingInfo().boundingBox.minimumWorld;
            pos.y = minimumPos.y;
            return pos;
        }

        function getWidthXOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.x - mesh.getBoundingInfo().boundingBox.minimumWorld.x;
        }

        function getWidthZOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.z - mesh.getBoundingInfo().boundingBox.minimumWorld.z;
        }

        function getHeightOfMesh(mesh) {
            return mesh.getBoundingInfo().boundingBox.maximumWorld.y - mesh.getBoundingInfo().boundingBox.minimumWorld.y;
        }

        function hideEntities(entities) {
            for (var index in entities) {
                entities[index].visibility = false;
            }
        }

        // =====
        // Creating new entities
        // =====

        function prepareNewEntityPlacement(entityType) {
            rendererGeneralState.newEntityPlacement = {
                placementInProgress : true,
                entityType : entityType,
                entity : game.entityPlacementMeshTemplates[entityType],
                desiredPosition : null
            }
        }
        */

    </script>
</body>
</html>
